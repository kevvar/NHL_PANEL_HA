<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NHL Game Panel</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    
    .container {
      height: 100vh;
      width: 100%;
      background: linear-gradient(160deg, #0e0f13 0%, #14161c 60%, #0e0f13 100%);
      color: white;
      overflow: hidden;
      position: relative;
    }
    .container::after {
      content: "";
      position: absolute;
      inset: 0;
      background-image: var(--league-bg, none);
      background-repeat: no-repeat;
      background-position: center;
      background-size: 70vmin;
      opacity: var(--league-opacity, 0.05);
      filter: grayscale(100%) contrast(110%);
      pointer-events: none;
    }
    
    .header {
      background: rgba(0, 0, 0, 0.6);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    
    .league-logo { height: 2.2rem; display: none; }
    
    .event-info h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
    }
    
    .event-info p {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.6);
    }
    
    .header-right { text-align: right; }
    
    .tv-network {
      font-size: 1rem;
      font-weight: 600;
      color: #ffffff;
      margin-bottom: 0.25rem;
      opacity: 0.85;
    }
    
    .game-date {
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.5);
    }
    
    .shots-header {
      max-width: 1100px;
      margin: 0 auto 1.25rem;
      padding: 0 1.25rem;
      width: 100%;
    }

    .shots-header .shots-bar-container {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 0.6rem;
      padding: 0.65rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      border: 1px solid rgba(255,255,255,0.04);
      backdrop-filter: blur(4px);
    }

    .shots-header .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .shots-header .stat-label {
      font-size: 0.82rem;
      color: rgba(255, 255, 255, 0.78);
      font-weight: 700;
      letter-spacing: 0.6px;
    }

    .shots-header .stat-values {
      display: flex;
      gap: 0.75rem;
      font-size: 1.05rem;
      font-weight: 800;
      align-items: center;
    }
    
    .shots-header .stat-value {
        font-size: 1.05rem;
    }
    .shots-header .stat-sep { color: rgba(255,255,255,0.35); font-weight:700 }

    .shots-header .stat-values [data-tooltip] { position: relative; cursor: default }
    .shots-header .stat-values [data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: calc(100% + 10px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 0.35rem 0.5rem;
      font-size: 0.8rem;
      border-radius: 4px;
      white-space: nowrap;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      z-index: 30;
    }

    .main-score {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 3rem;
      padding: 0 3rem 2rem 3rem;
      max-width: 1400px;
      margin: 0 auto;
      align-items: center;
    }
    
    .team { text-align: center; }
    
    .team-logo {
      width: 10rem;
      height: 10rem;
      margin: 0 auto 1.5rem;
      filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.5));
    }
    
    .team-name {
      font-size: 2.2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }
    
    .team-abbr {
      font-size: 1.3rem;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 1rem;
    }
    
    .team-record {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 1rem;
    }
    
    .team-badge {
      display: inline-block;
      padding: 0.5rem 1.5rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 0.5rem;
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .score-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .scores {
      display: flex;
      align-items: center;
      gap: 2rem;
      margin-bottom: 1.5rem;
    }
    
    .score {
      font-size: 4.5rem;
      font-weight: 900;
      line-height: 1;
    }
    .score.flip {
      display: inline-block;
      perspective: 600px;
      animation: flipNum 600ms ease-out;
    }
    @keyframes flipNum {
      0% { transform: rotateX(0deg); }
      40% { transform: rotateX(-90deg); opacity: 0.6; }
      60% { transform: rotateX(-90deg); opacity: 0.6; }
      100% { transform: rotateX(0deg); opacity: 1; }
    }
    
    .score.winner { color: #2ecc71; }
    .score.loser { color: rgba(255, 255, 255, 0.4); }
    
    .score-separator {
      font-size: 3rem;
      color: rgba(255, 255, 255, 0.3);
    }
    
    .status-badge {
      background: rgba(255, 255, 255, 0.08);
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 1.1rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      border: 1px solid rgba(255,255,255,0.15);
    }
    .live-inline {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    .live-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff3b30;
      box-shadow: 0 0 12px rgba(255, 59, 48, 0.7);
      animation: blink 1.2s ease-in-out infinite;
    }
    .live-text { font-weight: 800; color: #ff6b6b; letter-spacing: 0.5px; animation: blink 1.2s ease-in-out infinite; }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.25; } }
    
    .period-info {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 1rem;
    }
    .state-chips {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    .state-chip {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      color: rgba(255,255,255,0.9);
      font-weight: 600;
      font-size: 0.8rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
    }
    
    .winner-badge {
      background: rgba(46, 204, 113, 0.12);
      border: 1px solid rgba(46, 204, 113, 0.5);
      padding: 0.4rem 1.1rem;
      border-radius: 0.5rem;
      margin-top: 0.75rem;
    }
    
    .winner-text {
      color: #2ecc71;
      font-weight: 700;
      font-size: 1.1rem;
    }
    
    .container.goal-flash::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 8px;
      padding: 10px;
      box-sizing: border-box;
      pointer-events: none;
      background: linear-gradient(90deg, var(--goal-primary, #2ecc71), var(--goal-secondary, #a6f4c5));
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      box-shadow: inset 0 0 50px rgba(var(--goal-color-rgb, 46, 204, 113), 0.45), 0 0 50px rgba(var(--goal-color-rgb, 46, 204, 113), 0.45);
      animation: pulseBorder 5.0s ease-out 3;
    }
    @keyframes pulseBorder {
      0% { opacity: 0; }
      30% { opacity: 1; }
      60% { opacity: 0.7; }
      100% { opacity: 0; }
    }
    
    .game-details-grid {
      display: grid;
      grid-template-columns: 1fr; 
      gap: 1rem;
      padding: 0 1.25rem 1.5rem 1.25rem; 
      max-width: 1000px;
      margin: 0 auto;
    }
    
    .stat-card {
      display: none; 
    }
    
    .shots-bar {
      margin-top: 0.4rem;
      height: 12px;
      background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border-radius: 999px;
      overflow: hidden;
      display: flex;
      border: 1px solid rgba(0,0,0,0.25);
      position: relative;
    }
    .shots-bar .team { background: linear-gradient(90deg, var(--team-primary), rgba(0,0,0,0.02)); box-shadow: inset 0 -6px 12px rgba(0,0,0,0.12); }
    .shots-bar .opp { background: linear-gradient(90deg, var(--opponent-primary), rgba(0,0,0,0.02)); opacity: 0.95 }

    .shots-bar::before {
      content: '';
      position: absolute;
      height: 12px;
      width: 100%;
      border-radius: 999px;
      pointer-events: none;
      background-image: linear-gradient(90deg, rgba(255,255,255,0.02) 0.25rem, transparent 0.25rem);
      background-size: 1rem 100%;
      opacity: 0.25;
    }

    .shots-bar.pulse .team, .shots-bar.pulse .opp { animation: shotsPulse 900ms ease-out 1 }
    @keyframes shotsPulse { 0% { transform: translateY(0) } 50% { transform: translateY(-1px) scaleY(1.02) } 100% { transform: translateY(0) } }
    
    .last-play-section {
      padding: 0; 
      width: 100%;
    }
    
    .footer {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      padding: 1rem 3rem;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .footer-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .refresh-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.25);
      color: white;
      padding: 0.25rem 0.6rem;
      border-radius: 0.4rem;
      font-size: 0.85rem;
      cursor: pointer;
      margin-left: 0.5rem;
    }
    .refresh-btn:hover { background: rgba(255,255,255,0.08); }
    
    .footer-info span {
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.9rem;
      margin-right: 0.5rem;
    }
    
    .footer-info strong {
      color: white;
      font-weight: 600;
    }
    
    .last-update {
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.5);
    }
    
    .last-play-title {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 0.5rem;
      font-weight: 600;
    }
    
    .plays-timeline {
      max-height: 220px;
      overflow-y: auto;
      overflow-x: hidden;
      scroll-behavior: smooth;
      padding-right: 0.5rem;
    }
    
    .plays-timeline::-webkit-scrollbar {
      width: 6px;
    }
    
    .plays-timeline::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }
    
    .plays-timeline::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }
    
    .plays-timeline::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    .play-card {
      display: flex;
      flex-direction: row;
      gap: 0.75rem;
      align-items: center;
      min-height: 64px;
      justify-content: center;
      text-align: left;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border-radius: 0.6rem;
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.45rem;
      font-size: 0.98rem;
      line-height: 1.25;
      color: white;
      animation: slideIn 0.24s ease-out;
      transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .play-card:hover { transform: translateY(-4px); box-shadow: 0 10px 28px rgba(0,0,0,0.45); }

    .play-card.short { align-items: center; text-align: center; }
    .play-card.short .play-content { display: flex; flex-direction: column; align-items: center; text-align: center; }
    .play-card.short .play-time { order: 0; margin-top: 0; }
    .play-card.short .play-text { -webkit-line-clamp: 2; line-clamp: 2; }

    .play-content { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
    .play-time { color: rgba(255,255,255,0.85); font-size: 0.92rem; margin-bottom: 0.12rem; font-weight: 700; text-align: center; }
    .play-text { font-size: 1.05rem; color: #fff; font-weight: 600; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-clamp: 2; overflow-wrap: anywhere; text-align: center; }
    .play-card.expanded .play-text { -webkit-line-clamp: unset; line-clamp: unset; white-space: normal; }

    .play-card.new { background: rgba(255,255,255,0.06); animation: newPlayPulse 1s ease-out; border-color: rgba(255,255,255,0.07) }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes newPlayPulse {
      0%, 100% { background: rgba(255, 255, 255, 0.12); }
      50% { background: rgba(255, 255, 255, 0.24); }
    }
    
    .play-time {
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.8rem;
      margin-bottom: 0.25rem;
    }

    .touch-tooltip {
      position: fixed;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 0.35rem 0.6rem;
      border-radius: 6px;
      font-size: 0.85rem;
      z-index: 200;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      pointer-events: none;
      opacity: 0;
      transition: opacity 160ms ease;
    }
    
    .last-play-empty {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 0.5rem;
      padding: 1rem;
      text-align: center;
      color: rgba(255, 255, 255, 0.4);
      font-style: italic;
    }
    
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      height: 100vh;
      font-size: 1.5rem;
      gap: 1rem;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @media (min-width: 768px) and (max-width: 1400px) {
      .main-score { gap: 2rem; padding: 0 1.25rem 1.75rem 1.25rem; }
      .team-logo { width: 9.5rem; height: 9.5rem; }
      .team-name { font-size: 2.05rem; }
      .score { font-size: 4.6rem; }
      
      .game-details-grid { padding: 0 1.25rem 1.5rem 1.25rem; }

      .shots-header { padding: 0 1rem; margin-bottom: 1rem; }
      .plays-timeline { max-height: 360px; }
      .footer { padding: 1rem 1.25rem; }
    }
  </style>
</head>
<body>
  <div id="app" class="container"></div>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONFIGURATION - CHANGE THESE VALUES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const HA_URL = 'http://HA_IP:8123';
    const HA_TOKEN = 'TOKEN_HA';
    const INPUT_SELECT = 'input_select.nhl_team';
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NEW FUNCTION: Call NHL API through Home Assistant rest_command
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    /**
     * Calls the NHL API by reading REST sensors from Home Assistant
     * Sensors are automatically updated every X seconds
     */
    async function callNHLApiViaHA(nhlApiUrl) {
      try {
        // Determine which sensor to read based on URL
        let sensorEntity = '';
        
        if (nhlApiUrl.includes('/schedule/now')) {
          sensorEntity = 'sensor.nhl_schedule_now';
          addLog(`üì° Reading sensor: ${sensorEntity}`, 'info');
        } else if (nhlApiUrl.includes('/play-by-play')) {
          sensorEntity = 'sensor.nhl_play_by_play';
          addLog(`üì° Reading sensor: ${sensorEntity}`, 'info');
        } else {
          throw new Error('URL not supported in sensors');
        }
        
        // Read the HA sensor
        const response = await fetch(`${HA_URL}/api/states/${sensorEntity}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${HA_TOKEN}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const sensorData = await response.json();
        
        // API data is in the sensor attributes
        const apiData = sensorData.attributes || {};
        
        // Validate that we have data
        if (Object.keys(apiData).length === 0) {
          throw new Error('Sensor has no data - waiting for first update');
        }
        
        addLog(`‚úÖ Data read from sensor (${Object.keys(apiData).length} attributes)`, 'success');
        
        return apiData;
      } catch (error) {
        addLog(`‚ùå Error reading sensor: ${error.message}`, 'error');
        console.error('Error reading HA sensor:', error);
        throw error;
      }
    }
    
    /**
     * Updates the input_text with the current game ID
     * And activates/deactivates the active game flag
     */
    async function updateGameIdInHA(gameId, isActive = true) {
      try {
        // Update game ID
        const response1 = await fetch(`${HA_URL}/api/services/input_text/set_value`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${HA_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            entity_id: 'input_text.nhl_current_game_id',
            value: gameId || ''
          })
        });
        
        if (!response1.ok) {
          throw new Error(`HTTP ${response1.status}`);
        }
        
        // Activate/deactivate active game flag
        const booleanService = isActive ? 'turn_on' : 'turn_off';
        const response2 = await fetch(`${HA_URL}/api/services/input_boolean/${booleanService}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${HA_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            entity_id: 'input_boolean.nhl_game_active'
          })
        });
        
        if (!response2.ok) {
          throw new Error(`HTTP ${response2.status}`);
        }
        
        addLog(`‚úÖ Game ID: ${gameId || 'empty'} | Active: ${isActive}`, 'success');
        
        // Wait 2 seconds for the sensor to update
        await delay(2000);
        
      } catch (error) {
        addLog(`‚ö†Ô∏è Error updating game ID: ${error.message}`, 'warning');
        console.error('Error updating game ID:', error);
      }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GLOBAL VARIABLES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let currentSensor = null;
    let playsHistory = [];
    let lastScore = { team: 0, opponent: 0 };
    let isFirstLoad = true;
    
    let currentGameId = null;
    let currentTeamName = null;
    let processedGoalEvents = new Set();
    let pendingGoalEvents = new Map();
    let lastProcessedEventId = 0;
    let skipNextGoalProcessing = false;
    let activePenalties = new Map();
    let processedPenalties = new Set();
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GOAL PERSISTENCE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function loadProcessedGoals() {
      try {
        const stored = localStorage.getItem('nhl_processed_goals');
        if (stored) {
          const data = JSON.parse(stored);
          const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
          const validGoals = data.filter(item => item.timestamp > oneDayAgo);
          
          processedGoalEvents = new Set(validGoals.map(item => item.eventId));
          saveProcessedGoals();
          
          if (processedGoalEvents.size > 0) {
            addLog(`üî• ${processedGoalEvents.size} goal(s) already processed loaded`, 'info');
          }
        }
      } catch (error) {
        console.error('Error loading processed goals:', error);
        processedGoalEvents = new Set();
      }
    }
    
    function saveProcessedGoals() {
      try {
        const data = Array.from(processedGoalEvents).map(eventId => ({
          eventId: eventId,
          timestamp: Date.now()
        }));
        localStorage.setItem('nhl_processed_goals', JSON.stringify(data));
      } catch (error) {
        console.error('Error saving processed goals:', error);
      }
    }
    
    function clearOldProcessedGoals() {
      try {
        localStorage.removeItem('nhl_processed_goals');
        processedGoalEvents.clear();
        pendingGoalEvents.clear();
        skipNextGoalProcessing = true;
        
        clearAllPenalties(true);
        
        addLog('üóëÔ∏è Goals cleared - penalties reset', 'warning');
      } catch (error) {
        console.error('Error clearing goals:', error);
      }
    }
    
    function clearAllPenalties(keepProcessedHistory = false) {
      activePenalties.forEach((penalty, eventId) => {
        if (penalty.intervalId) {
          clearInterval(penalty.intervalId);
        }
      });
      
      activePenalties.clear();
      
      if (!keepProcessedHistory) {
        processedPenalties.clear();
      }
      
      const allPenaltyContainers = document.querySelectorAll('.penalty-container');
      allPenaltyContainers.forEach(container => container.remove());
      
      addLog(`üßπ Active penalties cleared${keepProcessedHistory ? ' (history preserved)' : ''}`, 'info');
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // LOGGING SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let logMessages = [];
    const MAX_LOG_MESSAGES = 15;
    
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function addLog(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString('es-ES', { 
        hour: '2-digit', 
        minute: '2-digit',
        second: '2-digit',
        timeZone: 'America/Costa_Rica'
      });
      
      logMessages.unshift({
        time: timestamp,
        message: message,
        type: type
      });
      
      if (logMessages.length > MAX_LOG_MESSAGES) {
        logMessages = logMessages.slice(0, MAX_LOG_MESSAGES);
      }
      
      updateLogPanel();
      console.log(`[NHL Debug ${timestamp}]`, message);
    }
    
    function updateLogPanel() {
      let logPanel = document.getElementById('nhlDebugLog');
      
      if (!logPanel) {
        logPanel = document.createElement('div');
        logPanel.id = 'nhlDebugLog';
        logPanel.style.cssText = `
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          width: 400px;
          max-height: 400px;
          background: rgba(0, 0, 0, 0.92);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 8px;
          padding: 10px;
          font-family: 'Courier New', monospace;
          font-size: 11px;
          color: #fff;
          overflow-y: auto;
          z-index: 9999;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
          backdrop-filter: blur(10px);
          transition: all 0.3s ease;
        `;
        
        const header = document.createElement('div');
        header.style.cssText = `
          font-weight: bold;
          margin-bottom: 8px;
          padding-bottom: 8px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.2);
          display: flex;
          justify-content: space-between;
          align-items: center;
        `;
        header.innerHTML = `
          <span>üèí NHL API Debug Log</span>
          <div>
            <button id="clearLogBtn" style="
              background: rgba(255, 59, 48, 0.8);
              border: none;
              color: white;
              padding: 2px 8px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 10px;
            ">Limpiar</button>
            <button id="clearGoalsBtn" style="
              background: rgba(255, 165, 0, 0.8);
              border: none;
              color: white;
              padding: 2px 8px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 10px;
              margin-left: 4px;
            " title="Clear saved goals">üóëÔ∏è</button>
            <button id="toggleLogBtn" style="
              background: rgba(100, 100, 100, 0.8);
              border: none;
              color: white;
              padding: 2px 8px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 10px;
              margin-left: 4px;
            " title="Minimizar/Maximizar">‚àí</button>
          </div>
        `;
        
        logPanel.appendChild(header);
        
        const messagesContainer = document.createElement('div');
        messagesContainer.id = 'logMessages';
        logPanel.appendChild(messagesContainer);
        
        document.body.appendChild(logPanel);
        
        document.getElementById('clearLogBtn').addEventListener('click', () => {
          logMessages = [];
          updateLogPanel();
        });
        
        document.getElementById('clearGoalsBtn').addEventListener('click', () => {
          clearOldProcessedGoals();
        });
        
        let isMinimized = false;
        document.getElementById('toggleLogBtn').addEventListener('click', (e) => {
          const btn = e.target;
          const messages = document.getElementById('logMessages');
          
          if (isMinimized) {
            logPanel.style.maxHeight = '400px';
            messages.style.display = 'block';
            btn.textContent = '‚àí';
            btn.title = 'Minimizar';
            isMinimized = false;
          } else {
            logPanel.style.maxHeight = '45px';
            messages.style.display = 'none';
            btn.textContent = '+';
            btn.title = 'Maximizar';
            isMinimized = true;
          }
        });
      }
      
      const messagesContainer = document.getElementById('logMessages');
      if (!messagesContainer) return;
      
      const typeColors = {
        info: '#00bfff',
        success: '#00ff88',
        warning: '#ffaa00',
        error: '#ff3b30'
      };
      
      messagesContainer.innerHTML = logMessages.map(log => `
        <div style="
          margin-bottom: 6px;
          padding: 4px;
          background: rgba(255, 255, 255, 0.03);
          border-radius: 4px;
          border-left: 3px solid ${typeColors[log.type] || typeColors.info};
        ">
          <span style="color: rgba(255, 255, 255, 0.5); font-size: 10px;">${log.time}</span><br>
          <span style="color: ${typeColors[log.type] || typeColors.info};">${log.message}</span>
        </div>
      `).join('');
      
      logPanel.style.setProperty('scrollbar-width', 'thin');
      logPanel.style.setProperty('scrollbar-color', 'rgba(255,255,255,0.3) rgba(0,0,0,0.3)');
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // NHL API FUNCTIONS - AHORA USA HOME ASSISTANT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async function findGameId(teamName) {
      try {
        addLog(`Looking for game ID: ${teamName}`, 'info');
        
        const url = `https://api-web.nhle.com/v1/schedule/now`;
        const data = await callNHLApiViaHA(url);
        
        if (!data.gameWeek || !Array.isArray(data.gameWeek)) {
          addLog('No gameWeek in schedule', 'warning');
          return null;
        }
        
        // Prepare flexible search
        const searchTerms = teamName.toLowerCase().trim();
        
        // Extract keywords (ignore short words like "de", "los", "las")
        const keywords = searchTerms
          .split(' ')
          .filter(word => word.length > 3 && !['the'].includes(word));
        
        for (const week of data.gameWeek) {
          if (!week.games || !Array.isArray(week.games)) continue;
          
          for (const game of week.games) {
            const homeTeam = game.homeTeam;
            const awayTeam = game.awayTeam;
            
            // Build full names
            const homeFullName = (homeTeam?.placeName?.default || '') + ' ' + (homeTeam?.commonName?.default || '');
            const awayFullName = (awayTeam?.placeName?.default || '') + ' ' + (awayTeam?.commonName?.default || '');
            const homeAbbrev = homeTeam?.abbrev || '';
            const awayAbbrev = awayTeam?.abbrev || '';
            
            // Method 1: Exact abbreviation comparison (most reliable)
            if (homeAbbrev.toUpperCase() === teamName.toUpperCase() ||
                awayAbbrev.toUpperCase() === teamName.toUpperCase()) {
              
              const isHome = homeAbbrev.toUpperCase() === teamName.toUpperCase();
              addLog(`‚úî Game found by ABBREV: ${game.id} (${isHome ? 'HOME' : 'AWAY'}) - State: ${game.gameState}`, 'success');
              
              return {
                gameId: game.id,
                isHome: isHome,
                gameState: game.gameState
              };
            }
            
            // Method 2: Exact full name comparison
            if (homeFullName.toLowerCase() === searchTerms ||
                awayFullName.toLowerCase() === searchTerms) {
              
              const isHome = homeFullName.toLowerCase() === searchTerms;
              addLog(`‚úî Game found by EXACT NAME: ${game.id} (${isHome ? 'HOME' : 'AWAY'}) - State: ${game.gameState}`, 'success');
              
              return {
                gameId: game.id,
                isHome: isHome,
                gameState: game.gameState
              };
            }
            
            // Method 3: Flexible keyword search
            const homeMatches = keywords.every(keyword => 
              homeFullName.toLowerCase().includes(keyword)
            );
            const awayMatches = keywords.every(keyword => 
              awayFullName.toLowerCase().includes(keyword)
            );
            
            if (homeMatches || awayMatches) {
              const isHome = homeMatches;
              addLog(`‚úî Game found by KEYWORDS: ${game.id} (${isHome ? 'HOME' : 'AWAY'}) - State: ${game.gameState}`, 'success');
              addLog(`   Search: "${teamName}" ‚Üí Match: "${isHome ? homeFullName : awayFullName}"`, 'info');
              
              return {
                gameId: game.id,
                isHome: isHome,
                gameState: game.gameState
              };
            }
          }
        }
        
        addLog(`No game found for: ${teamName}`, 'warning');
        addLog(`üí° Tip: Try using the team abbreviation (e.g.: VGK, WPG, TOR)`, 'info');
        return null;
      } catch (error) {
        addLog(`Error searching game ID: ${error.message}`, 'error');
        console.error('Error finding game ID:', error);
        return null;
      }
    }
    
    async function fetchPlayByPlay(gameId) {
      try {
        const url = `https://api-web.nhle.com/v1/gamecenter/${gameId}/play-by-play`;
        const data = await callNHLApiViaHA(url);
        
        addLog(`‚úî Play-by-play got it (${data.plays?.length || 0} events)`, 'success');
        return data;
      } catch (error) {
        addLog(`Error fetchPlayByPlay: ${error.message}`, 'error');
        console.error('Error fetching play-by-play:', error);
        return null;
      }
    }
    
    async function sendTelegramNotification(message, teamName = '') {
      try {
        const response = await fetch(`${HA_URL}/api/services/telegram_bot/send_message`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${HA_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: message,
            config_entry_id: '01JZ8T7GBG18VJ977E5P7YTBKH',
            target: ['697025642'],
          })
        });
        
        if (!response.ok) {
          addLog(`Error sending notification: HTTP ${response.status}`, 'error');
        }
      } catch (error) {
        addLog(`Error sending notification: ${error.message}`, 'error');
        console.error('Error sending notification:', error);
      }
    }
    
    async function processGoalEvents(playByPlayData, gameId, teamName = '') {
      if (!playByPlayData?.plays) return;
      
      if (skipNextGoalProcessing) {
        const plays = playByPlayData.plays;
        for (const play of plays) {
          if (play.typeDescKey === 'goal' && play.details?.highlightClipSharingUrl) {
            processedGoalEvents.add(play.eventId);
          }
        }
        saveProcessedGoals();
        skipNextGoalProcessing = false;
        addLog(`‚úî ${processedGoalEvents.size} existing goal(s) marked (not resent)`, 'info');
        return;
      }
      
      const plays = playByPlayData.plays;
      let newGoalsDetected = 0;
      let urlsFound = 0;
      
      for (const play of plays) {
        if (play.typeDescKey !== 'goal') continue;
        
        const eventId = play.eventId;
        
        if (processedGoalEvents.has(eventId)) continue;
        
        const urlEn = play.details?.highlightClipSharingUrl || '';
        const urlFr = play.details?.highlightClipSharingUrlFr || '';
        
        const isCompleteUrl = (url) => url && url !== 'https://nhl.com/video/' && url.length > 30;
        
        const hasValidUrl = isCompleteUrl(urlEn) || isCompleteUrl(urlFr);
        
        if (hasValidUrl) {
          if (pendingGoalEvents.has(eventId)) {
            const pending = pendingGoalEvents.get(eventId);
            addLog(`‚úî Goal URL found after ${pending.attempts} attempts (Event ${eventId})`, 'success');
            pendingGoalEvents.delete(eventId);
          }
          
          let finalUrl = '';
          if (isCompleteUrl(urlEn)) {
            finalUrl = urlEn;
            addLog(`üîó Using EN URL: ${urlEn.substring(0, 50)}...`, 'info');
          } else if (isCompleteUrl(urlFr)) {
            finalUrl = urlFr;
            addLog(`üîó Using FR URL (fallback): ${urlFr.substring(0, 50)}...`, 'warning');
          }
          
          const time = play.timeInPeriod || '';
          const period = play.periodDescriptor?.number || '';
          
          await sendTelegramNotification(
            `üö® GOAL! Period ${period} - ${time}\n${finalUrl}`,
            teamName
          );
          
          addLog(`üì± Notification sent: Goal P${period} ${time}`, 'success');
          
          processedGoalEvents.add(eventId);
          urlsFound++;
          
          saveProcessedGoals();
        } else {
          if (!pendingGoalEvents.has(eventId)) {
            const time = play.timeInPeriod || '';
            const period = play.periodDescriptor?.number || '';
            
            pendingGoalEvents.set(eventId, {
              eventData: play,
              attempts: 1,
              firstSeen: Date.now(),
              period: period,
              time: time
            });
            
            addLog(`üéØ New goal detected (Event ${eventId}) P${period} ${time} - Waiting for URL...`, 'warning');
            newGoalsDetected++;
          } else {
            const pending = pendingGoalEvents.get(eventId);
            pending.attempts++;
            pendingGoalEvents.set(eventId, pending);
            
            if (pending.attempts % 5 === 0) {
              const waitTime = Math.round((Date.now() - pending.firstSeen) / 1000);
              addLog(`‚è≥ Waiting for URL (Event ${eventId}) - Attempt ${pending.attempts} (${waitTime}s)`, 'info');
            }
          }
        }
      }
      
      if (newGoalsDetected > 0 || urlsFound > 0 || pendingGoalEvents.size > 0) {
        const summary = [];
        if (newGoalsDetected > 0) summary.push(`${newGoalsDetected} new`);
        if (urlsFound > 0) summary.push(`${urlsFound} URL(s) found`);
        if (pendingGoalEvents.size > 0) summary.push(`${pendingGoalEvents.size} pending`);
        
        addLog(`üìä Goals: ${summary.join(', ')}`, 'info');
      }
    }
    
    /**
     * Processes penalties and marks them as processed
     * UPDATED: NO longer creates cards, only registers events
     */
    function processPenalties(playByPlayData, isHome) {
      if (!playByPlayData?.plays) return;
      
      const plays = playByPlayData.plays;
      let newPenaltiesDetected = 0;
      let skippedPenalties = 0;
      
      for (const play of plays) {
        if (play.typeDescKey !== 'penalty') continue;
        
        const eventId = play.eventId;
        
        if (processedPenalties.has(eventId)) {
          skippedPenalties++;
          continue;
        }
        
        const duration = play.details?.duration || 2;
        const teamSide = determineTeamFromEvent(play, playByPlayData);
        if (teamSide === null) continue;
        
        const isPenaltyOnHome = (teamSide === 'home');
        const powerPlayTeam = isPenaltyOnHome ? 'away' : 'home';
        
        processedPenalties.add(eventId);
        newPenaltiesDetected++;
        
        addLog(`‚ö†Ô∏è Penalty detected: ${teamSide.toUpperCase()} (${duration} min) - Event ${eventId}`, 'warning');
      }
      
      // ALWAYS check situationCode to update cards
      checkPowerPlayStatus(playByPlayData, isHome);
      
      if (newPenaltiesDetected > 0 || skippedPenalties > 0) {
        addLog(`üìä Penalties: ${newPenaltiesDetected} new, ${skippedPenalties} already processed`, 'info');
      }
    }
    
    /**
     * Checks current situationCode and manages the single power play card
     * REFACTORED: Now creates/updates ONE SINGLE card based 100% on situationCode
     */
    function checkPowerPlayStatus(playByPlayData, isHome) {
      if (!playByPlayData?.plays || playByPlayData.plays.length === 0) return;
      
      // Get the latest play to check situationCode
      const latestPlay = playByPlayData.plays[playByPlayData.plays.length - 1];
      const currentSituation = latestPlay?.situationCode || "1551";
      const homeDefending = latestPlay?.homeTeamDefendingSide;
      
      // Parse situationCode (format: "1451" = AWAY: 1G 4P, HOME: 5P 1G)
      if (currentSituation.length === 4) {
        const awayGoalies = parseInt(currentSituation[0]);
        const awayPlayers = parseInt(currentSituation[1]);
        const homePlayers = parseInt(currentSituation[2]);
        const homeGoalies = parseInt(currentSituation[3]);
        
        // Detect empty net (goalie = 0)
        const homeEmptyNet = homeGoalies === 0;
        const awayEmptyNet = awayGoalies === 0;
        const hasEmptyNet = homeEmptyNet || awayEmptyNet;
        
        // If there's empty net, show EMPTY NET card
        if (hasEmptyNet) {
          // The team WITHOUT goalie is where the card is shown
          const emptyNetTeam = homeEmptyNet ? 'home' : 'away';
          
          // Determine position in THE PANEL
          const weAreHome = isHome;
          const isOurEmptyNet = (weAreHome && homeEmptyNet) || (!weAreHome && awayEmptyNet);
          const showOnRight = !isOurEmptyNet; // If NOT our empty net, goes to the right
          
          const side = showOnRight ? 'RIGHT (OPPONENT)' : 'LEFT (US)';
          addLog(`ü•Ö EMPTY NET detected in ${emptyNetTeam.toUpperCase()} - ${side}`, 'info');
          
          const situationId = `situation_${emptyNetTeam}_EN`;
          const existingCard = document.querySelector(`.penalty-card[data-penalty-id="${situationId}"]`);
          
          if (!existingCard) {
            removeAllPowerPlayCards();
            createPowerPlayCard(situationId, showOnRight, homeDefending, 0, 0, true);
            
            activePenalties.set(situationId, {
              intervalId: null,
              showOnRight: showOnRight,
              startTime: Date.now(),
              situation: 'EN',
              emptyNet: true
            });
          }
          return;
        }
        
        // Detect if there's numerical advantage (power play)
        const hasPowerPlay = homePlayers !== awayPlayers;
        
        if (!hasPowerPlay) {
          // Even game (5v5, 4v4, 3v3, etc.) - remove all cards
          if (activePenalties.size > 0) {
            addLog(`‚úÖ Even game - Situation: ${currentSituation} (${homePlayers}v${awayPlayers})`, 'success');
            removeAllPowerPlayCards();
          }
          return;
        }
        
        // THERE IS power play - determine who has advantage
        let powerPlayTeam, advantagePlayers, disadvantagePlayers;
        
        if (homePlayers > awayPlayers) {
          // HOME has MORE players = HOME has ADVANTAGE (AWAY has penalty)
          powerPlayTeam = 'home';
          advantagePlayers = homePlayers;
          disadvantagePlayers = awayPlayers;
        } else {
          // AWAY has MORE players = AWAY has ADVANTAGE (HOME has penalty)
          powerPlayTeam = 'away';
          advantagePlayers = awayPlayers;
          disadvantagePlayers = homePlayers;
        }
        
        // Determine position in THE PANEL (not according to NHL standard)
        // teams[0] = Your team (left), teams[1] = Opponent (right)
        // The card goes where the team with advantage IS in YOUR panel
        const weAreHome = isHome;
        const weHaveAdvantage = (weAreHome && powerPlayTeam === 'home') || (!weAreHome && powerPlayTeam === 'away');
        const showOnRight = !weHaveAdvantage; // If NOT ours, goes to the right (opponent)
        
        const side = showOnRight ? 'RIGHT (OPPONENT)' : 'LEFT (US)';
        const penalizedTeam = powerPlayTeam === 'home' ? 'AWAY' : 'HOME';
        
        // COMPLETE DEBUG
        addLog(`üîç DEBUG situationCode: ${currentSituation}`, 'debug');
        addLog(`üîç DEBUG parsed: AWAY=${awayGoalies}G ${awayPlayers}P vs HOME=${homeGoalies}G ${homePlayers}P`, 'debug');
        addLog(`üîç DEBUG powerPlayTeam="${powerPlayTeam}" (who HAS advantage)`, 'debug');
        addLog(`üîç DEBUG penalizedTeam="${penalizedTeam}" (who COMMITTED penalty)`, 'debug');
        addLog(`üîç DEBUG weAreHome=${weAreHome}, weHaveAdvantage=${weHaveAdvantage}`, 'debug');
        addLog(`üîç DEBUG showOnRight=${showOnRight} (${side})`, 'debug');
        
        addLog(`‚ö° PP: ${powerPlayTeam.toUpperCase()} has advantage (${penalizedTeam} penalized) ${advantagePlayers}v${disadvantagePlayers} - ${weHaveAdvantage ? 'OURS' : 'OPPONENT'} - ${side}`, 'info');
        
        
        // Create unique ID for this situation
        const situationId = `situation_${powerPlayTeam}_${advantagePlayers}v${disadvantagePlayers}`;
        
        // Check if a card already exists for this situation
        const existingCard = document.querySelector(`.penalty-card[data-penalty-id="${situationId}"]`);
        
        if (existingCard) {
          // Card already exists, just update the numerical text
          const situationEl = existingCard.querySelector('.power-play-situation');
          if (situationEl) {
            situationEl.textContent = `${advantagePlayers}v${disadvantagePlayers}`;
          }
        } else {
          // Card doesn't exist - remove any old cards and create new one
          removeAllPowerPlayCards();
          createPowerPlayCard(situationId, showOnRight, homeDefending, advantagePlayers, disadvantagePlayers, false);
          
          // Save reference
          activePenalties.set(situationId, {
            intervalId: null,
            showOnRight: showOnRight,
            startTime: Date.now(),
            situation: `${advantagePlayers}v${disadvantagePlayers}`,
            emptyNet: false
          });
        }
      }
    }
    
    /**
     * Removes all active power play cards
     */
    function removeAllPowerPlayCards() {
      activePenalties.forEach((penalty, eventId) => {
        if (penalty.intervalId) {
          clearInterval(penalty.intervalId);
        }
        
        const cards = document.querySelectorAll(`.penalty-card[data-penalty-id="${eventId}"]`);
        cards.forEach(card => {
          card.style.animation = 'penaltySlideOut 0.3s ease-out';
          setTimeout(() => {
            card.remove();
            
            const container = card.closest('.penalty-container');
            if (container && container.children.length === 0) {
              container.remove();
            }
          }, 300);
        });
      });
      
      activePenalties.clear();
      addLog(`üßπ All Power Play cards removed`, 'info');
    }
    
    function determineTeamFromEvent(play, playByPlayData) {
      if (!play.details?.eventOwnerTeamId) return null;
      
      const penaltyTeamId = play.details.eventOwnerTeamId;
      
      const homeTeamId = playByPlayData.homeTeam?.id;
      const awayTeamId = playByPlayData.awayTeam?.id;
      
      if (penaltyTeamId === homeTeamId) return 'home';
      if (penaltyTeamId === awayTeamId) return 'away';
      
      return null;
    }
    
    /**
     * Creates a single visual POWER PLAY card based on situationCode
     */
    function createPowerPlayCard(situationId, showOnRight, homeDefending, advantagePlayers = 5, disadvantagePlayers = 4, isEmptyNet = false, retryCount = 0) {
      const teams = document.querySelectorAll('.main-score .team');
      
      if (teams.length !== 2) {
        if (retryCount < 3) {
          addLog(`‚è≥ DOM not ready, retrying to create power play card (${retryCount + 1}/3)...`, 'info');
          setTimeout(() => {
            createPowerPlayCard(situationId, showOnRight, homeDefending, advantagePlayers, disadvantagePlayers, isEmptyNet, retryCount + 1);
          }, 500);
          return;
        } else {
          addLog(`‚ùå Error: 2 teams not found in DOM after 3 attempts`, 'error');
          return;
        }
      }
      
      // teams[0] = Your team (left), teams[1] = Opponent (right)
      const targetTeam = showOnRight ? teams[1] : teams[0];
      
      const side = showOnRight ? 'RIGHT (OPPONENT)' : 'LEFT (US)';
      addLog(`üìç Creating card at: ${side}`, 'info');
      
      let penaltyContainer = targetTeam.querySelector('.penalty-container');
      
      if (!penaltyContainer) {
        penaltyContainer = document.createElement('div');
        penaltyContainer.className = 'penalty-container';
        penaltyContainer.style.cssText = `
          position: absolute;
          bottom: 0;
          ${showOnRight ? 'right: 0;' : 'left: 0;'}
          display: flex;
          flex-direction: column;
          gap: 0.4rem;
          z-index: 10;
          pointer-events: none;
        `;
        
        targetTeam.style.position = 'relative';
        targetTeam.appendChild(penaltyContainer);
      }
      
      const card = document.createElement('div');
      card.className = 'penalty-card';
      card.setAttribute('data-penalty-id', situationId);
      
      const borderColor = isEmptyNet ? '#f39c12' : '#2ecc71';
      const bgGradient = isEmptyNet 
        ? 'linear-gradient(135deg, rgba(243, 156, 18, 0.15), rgba(230, 126, 34, 0.15))'
        : 'linear-gradient(135deg, rgba(46, 204, 113, 0.15), rgba(52, 211, 153, 0.15))';
      
      card.style.cssText = `
        background: ${bgGradient};
        border-left: 3px solid ${borderColor};
        border-radius: 0.4rem;
        padding: 0.5rem 0.7rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        backdrop-filter: blur(4px);
        animation: penaltySlideIn 0.3s ease-out;
        pointer-events: auto;
      `;
      
      card.innerHTML = `
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="font-size: 1.1rem;">${isEmptyNet ? 'ü•Ö' : '‚ö°'}</span>
          <span style="font-size: 0.8rem; font-weight: 600; color: ${isEmptyNet ? '#f39c12' : '#2ecc71'};">${isEmptyNet ? 'EMPTY NET' : 'POWER PLAY'}</span>
        </div>
        ${isEmptyNet ? '' : `<div style="
          font-size: 0.95rem;
          font-weight: 700;
          color: #fff;
          min-width: 2.5rem;
          text-align: right;
        " class="power-play-situation">
          ${advantagePlayers}v${disadvantagePlayers}
        </div>`}
      `;
      
      penaltyContainer.appendChild(card);
      
      if (!document.getElementById('penaltyAnimations')) {
        const style = document.createElement('style');
        style.id = 'penaltyAnimations';
        style.textContent = `
          @keyframes penaltySlideIn {
            from {
              opacity: 0;
              transform: translateX(${showOnRight ? '' : '-'}20px);
            }
            to {
              opacity: 1;
              transform: translateX(0);
            }
          }
          
          @keyframes penaltySlideOut {
            from {
              opacity: 1;
              transform: translateX(0) scale(1);
            }
            to {
              opacity: 0;
              transform: translateX(${showOnRight ? '' : '-'}20px) scale(0.9);
            }
          }
        `;
        document.head.appendChild(style);
      }
      
      addLog(`‚úÖ Card created: ${advantagePlayers}v${disadvantagePlayers} - ${side}`, 'success');
    }
    
    function formatPenaltyTime(seconds) {
      if (seconds <= 0) return '0:00';
      
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    /**
     * Restores active POWER PLAY cards after re-rendering the HTML
     * Called after updatePanel() to recover visual cards
     */
    function restorePenaltyCards() {
      if (activePenalties.size === 0) return;
      
      addLog(`‚ôªÔ∏è Restoring ${activePenalties.size} card(s)...`, 'info');
      
      activePenalties.forEach((penalty, situationId) => {
        if (penalty.emptyNet) {
          // It's EMPTY NET, no numbers
          createPowerPlayCard(situationId, penalty.showOnRight, null, 0, 0, true, 0);
        } else {
          // It's POWER PLAY, extract situation from ID
          const parts = situationId.split('_');
          const situation = parts[2] || '5v4';
          const [adv, disadv] = situation.split('v').map(n => parseInt(n) || 5);
          createPowerPlayCard(situationId, penalty.showOnRight, null, adv, disadv, false, 0);
        }
      });
    }
    
    async function processNHLData(teamName, teamHomeAway = 'home') {
      if (currentTeamName && currentTeamName !== teamName) {
        addLog(`üîÑ Team change detected: ${currentTeamName} ‚Üí ${teamName}`, 'warning');
        currentGameId = null;
        currentTeamName = teamName;
        processedGoalEvents.clear();
        pendingGoalEvents.clear();
        clearAllPenalties(false);
      }
      
      if (!currentGameId) {
        currentTeamName = teamName;
        
        const gameInfo = await findGameId(teamName);
        if (gameInfo) {
          currentGameId = gameInfo.gameId;
          addLog(`üèí Starting game monitoring ${currentGameId}`, 'success');
          
          // IMPORTANT: Update input_text in HA and activate flag
          await updateGameIdInHA(currentGameId, true);
          
          clearAllPenalties(false);
        } else {
          addLog(`‚ùå No active game found for ${teamName}`, 'error');
          return;
        }
      }
      
      await delay(500);
      
      const playByPlayData = await fetchPlayByPlay(currentGameId);
      if (!playByPlayData) {
        addLog(`‚ùå Error getting play-by-play for game ${currentGameId}`, 'error');
        currentGameId = null;
        return;
      }
      
      // Normalize teamHomeAway to lowercase
      const isHome = (teamHomeAway || 'home').toLowerCase() === 'home';
      
      processPenalties(playByPlayData, isHome);
      
      await processGoalEvents(playByPlayData, currentGameId, teamName);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HOME ASSISTANT DATA FUNCTIONS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async function fetchHAData(entityId) {
      try {
        const response = await fetch(`${HA_URL}/api/states/${entityId}`, {
          headers: {
            'Authorization': `Bearer ${HA_TOKEN}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) throw new Error('Error fetching data');
        return await response.json();
      } catch (error) {
        console.error('Error:', error);
        return null;
      }
    }
    
    function formatDate(dateStr) {
      if (!dateStr) return 'TBD';
      try {
        const date = new Date(dateStr);
        return date.toLocaleDateString('es-ES', { 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric',
          timeZone: 'America/Costa_Rica'
        });
      } catch (e) {
        return dateStr;
      }
    }
    
    function formatTime(timeStr) {
      if (!timeStr) return new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', timeZone: 'America/Costa_Rica' });
      try {
        const date = new Date(timeStr);
        return date.toLocaleTimeString('es-ES', { 
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
          timeZone: 'America/Costa_Rica'
        });
      } catch (e) {
        return timeStr;
      }
    }
    
    function convertClockTimeZone(clockStr) {
      if (!clockStr) return clockStr;
      
      try {
        // Detectar EST o EDT en la cadena
        const matchEST = clockStr.match(/(\d{1,2})\/(\d{1,2})\s*-\s*(\d{1,2}):(\d{2})\s*(AM|PM)\s*(EST|EDT)/i);
        
        if (!matchEST) return clockStr; // Si no coincide, devolver original
        
        const month = parseInt(matchEST[1]);
        let day = parseInt(matchEST[2]);
        const hour = parseInt(matchEST[3]);
        const minute = parseInt(matchEST[4]);
        const period = matchEST[5].toUpperCase();
        const timezone = matchEST[6].toUpperCase();
        
        // Convert to 24h format
        let hour24 = hour;
        if (period === 'PM' && hour !== 12) hour24 += 12;
        if (period === 'AM' && hour === 12) hour24 = 0;
        
        // Calculate time difference
        // EST = GMT-5, Your zone = GMT-6 ‚Üí Difference: -1 hour (60 minutes)
        // EDT = GMT-4, Your zone = GMT-6 ‚Üí Difference: -2 hours (120 minutes)
        const offsetMinutes = (timezone === 'EDT') ? 120 : 60;
        
        let totalMinutes = hour24 * 60 + minute;
        totalMinutes -= offsetMinutes; // Subtract difference
        
        // Handle day change
        let newMonth = month;
        if (totalMinutes < 0) {
          totalMinutes += 1440; // Add 24 hours
          day -= 1;
          if (day < 1) {
            // Previous day of previous month
            day = 31; // Simplification (works for most cases)
            newMonth -= 1;
            if (newMonth < 1) newMonth = 12;
          }
        } else if (totalMinutes >= 1440) {
          totalMinutes -= 1440;
          day += 1;
          // Here you could validate days of the month, but for simplicity...
        }
        
        // Convert back to 12h
        const newHour24 = Math.floor(totalMinutes / 60);
        const newMinute = totalMinutes % 60;
        
        const newPeriod = newHour24 < 12 ? 'AM' : 'PM';
        const newHour12 = newHour24 % 12 || 12;
        
        const minuteStr = String(newMinute).padStart(2, '0');
        return `${newMonth}/${day} - ${newHour12}:${minuteStr} ${newPeriod}`;
      } catch (e) {
        console.error('Error converting timezone:', e);
        return clockStr;
      }
    }
    
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(String(hex || ''));
      return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255, 255, 255';
    }
    
    function applyTeamColors(attr) {
      const appEl = document.getElementById('app');
      const leagueBg = (attr.league_logo && typeof attr.league_logo === 'string') ? `url('${attr.league_logo}')` : 'none';
      appEl && appEl.style.setProperty('--league-bg', leagueBg);
      let color1 = '#2ecc71';
      let color2 = '#ffffff';
      if (attr.team_colors) {
        const parts = String(attr.team_colors).split(',');
        if (parts.length >= 1 && /^#/.test(parts[0].trim())) color1 = parts[0].trim();
        if (parts.length >= 2 && /^#/.test(parts[1].trim())) color2 = parts[1].trim();
      }
      document.documentElement.style.setProperty('--team-primary', color1);
      document.documentElement.style.setProperty('--team-secondary', color2);
      document.documentElement.style.setProperty('--team-primary-rgb', hexToRgb(color1));
      let opp1 = '#c41230';
      let opp2 = '#ffffff';
      if (attr.opponent_colors) {
        const op = String(attr.opponent_colors).split(',');
        if (op.length >= 1 && /^#/.test(op[0].trim())) opp1 = op[0].trim();
        if (op.length >= 2 && /^#/.test(op[1].trim())) opp2 = op[1].trim();
      }
      document.documentElement.style.setProperty('--opponent-primary', opp1);
      document.documentElement.style.setProperty('--opponent-secondary', opp2);
      document.documentElement.style.setProperty('--opponent-primary-rgb', hexToRgb(opp1));
    }
    
    function checkForGoal(attr) {
      const currentScoreTeam = attr.team_score || 0;
      const currentScoreOpponent = attr.opponent_score || 0;
      
      if (!isFirstLoad) {
        let scorer = null;
        if (currentScoreTeam > lastScore.team) scorer = 'team';
        if (currentScoreOpponent > lastScore.opponent) scorer = 'opponent';
        if (scorer) {
          triggerGoalAnimation(scorer);
        }
      }
      
      lastScore = {
        team: currentScoreTeam,
        opponent: currentScoreOpponent
      };
      isFirstLoad = false;
    }
    
    function triggerGoalAnimation(whoScored) {
      const container = document.getElementById('app');
      const goalPrimary = whoScored === 'opponent' ? getComputedStyle(document.documentElement).getPropertyValue('--opponent-primary').trim() : getComputedStyle(document.documentElement).getPropertyValue('--team-primary').trim();
      const goalSecondary = whoScored === 'opponent' ? getComputedStyle(document.documentElement).getPropertyValue('--opponent-secondary').trim() : getComputedStyle(document.documentElement).getPropertyValue('--team-secondary').trim();
      const goalRgb = whoScored === 'opponent' ? getComputedStyle(document.documentElement).getPropertyValue('--opponent-primary-rgb').trim() : getComputedStyle(document.documentElement).getPropertyValue('--team-primary-rgb').trim();
      container.style.setProperty('--goal-primary', goalPrimary || '#2ecc71');
      container.style.setProperty('--goal-secondary', goalSecondary || '#a6f4c5');
      container.style.setProperty('--goal-color-rgb', goalRgb || '46, 204, 113');
      container.style.setProperty('--goal-color', goalPrimary || '#2ecc71');
      container.classList.add('goal-flash');
      
      setTimeout(() => {
        container.classList.remove('goal-flash');
      }, 2000);
    }
    
    function addPlayToHistory(lastPlay, clock) {
      if (!lastPlay || lastPlay.trim() === '') return;
      
      const playWithTime = {
        text: lastPlay,
        time: convertClockTimeZone(clock) || 'Live',
        timestamp: Date.now()
      };
      
      if (playsHistory.length === 0 || playsHistory[0].text !== lastPlay) {
        playsHistory.unshift(playWithTime);
        playsHistory = playsHistory.slice(0, 10);
          if (!window._newPlaysCount) window._newPlaysCount = 0;
          window._newPlaysCount += 1;
          const newBadge = document.getElementById('newPlaysBadge');
          if (newBadge && userScrolledAway) {
            newBadge.innerText = `NUEVAS (${window._newPlaysCount})`;
            newBadge.style.display = 'block';
          }
          updatePlaysTimeline(true);
      }
    }
    
    let userScrolledAway = false;
    function updatePlaysTimeline(isNew = false, statusMsg = '') {
      const timeline = document.getElementById('playsTimeline');
      if (!timeline) return;

      if (playsHistory.length === 0) {
        const msg = statusMsg || 'Waiting for game action...';
        timeline.innerHTML = `<div class="last-play-empty">${msg}</div>`;
        return;
      }

      timeline.innerHTML = playsHistory.map((play, index) => {
        const text = String(play.text || '');
        const textLower = text.toLowerCase();
        const newClass = (index === 0 && isNew) ? ' new' : '';
        const isShort = text.trim().length > 0 && text.trim().length <= 30;
        const shortClass = isShort ? ' short' : '';

        return `
          <div class="play-card${newClass}${shortClass}">
            <div class="play-content">
              <div class="play-time">${play.time}</div>
              <div class="play-text">${play.text}</div>
            </div>
          </div>
        `;
      }).join('');

      if (isNew && !userScrolledAway) {
        timeline.scrollTop = 0;
      }

      if (!timeline._scrollBound) {
        timeline.addEventListener('scroll', () => {
          userScrolledAway = timeline.scrollTop > 10;
          const newBadge = document.getElementById('newPlaysBadge');
          if (!userScrolledAway) {
            if (window._newPlaysCount) window._newPlaysCount = 0;
            if (newBadge) newBadge.style.display = 'none';
          } else {
            if (newBadge && window._newPlaysCount) {
              newBadge.innerText = `NUEVAS (${window._newPlaysCount})`;
              newBadge.style.display = 'block';
            }
          }
        });
        timeline._scrollBound = true;
      }
    }
    
    let refreshIntervalMs = 30000;
    let refreshTimer = null;
    function setRefreshInterval(ms) {
      if (refreshTimer) clearInterval(refreshTimer);
      refreshIntervalMs = ms;
      refreshTimer = setInterval(updatePanel, refreshIntervalMs);
    }

    let pendingScoreFlip = null;
    function manualRefresh() {
      updatePanel(true);
      setRefreshInterval(refreshIntervalMs);
    }

    async function updatePanel(force = false) {
      const app = document.getElementById('app');
      
      const inputData = await fetchHAData(INPUT_SELECT);
      if (!inputData) {
        app.innerHTML = `
          <div class="loading">
            <div class="spinner"></div>
            <div>Conecting with Home Assistant...</div>
            <div style="font-size: 0.9rem; color: rgba(255,255,255,0.5);">Check URL and TOKEN</div>
          </div>
        `;
        return;
      }
      
      const teamNameFromHA = inputData.attributes?.friendly_name || inputData.state;
      
      const teamNameNormalized = inputData.state.replace(/ /g, '_').toLowerCase();
      const sensorName = `sensor.${teamNameNormalized}`;
      
      const sensorData = await fetchHAData(sensorName);
      if (!sensorData) {
        app.innerHTML = `
          <div class="loading">
            <div class="spinner"></div>
            <div>Waiting for sensor data...</div>
            <div style="font-size: 0.9rem; color: rgba(255,255,255,0.5);">${sensorName}</div>
          </div>
        `;
        return;
      }
      
      const attr = sensorData.attributes;
      
      const gameState = sensorData.state.toUpperCase(); 
      const live = gameState === 'IN';
      
      if (live) {
        await processNHLData(teamNameFromHA, attr.team_homeaway);
      } else if (gameState === 'PRE' || gameState === 'FUT') {
        if (!currentGameId) {
          const gameInfo = await findGameId(teamNameFromHA);
          if (gameInfo) {
            currentGameId = gameInfo.gameId;
            addLog(`üèí Game found (PRE): ${currentGameId} - Waiting for start...`, 'info');
            // DON'T activate flag yet, just save the ID
            await updateGameIdInHA(currentGameId, false);
          }
        }
      } else {
        if (currentGameId) {
          addLog(`‚úÖ Game ${currentGameId} ended - Cleaning data`, 'info');
          clearOldProcessedGoals();
          currentGameId = null;
          
          // Clear game ID in HA and deactivate flag
          await updateGameIdInHA('', false);
        }
        pendingGoalEvents.clear();
      }
      
      applyTeamColors(attr);
      
      const prevTeam = lastScore.team;
      const prevOpp = lastScore.opponent;
      checkForGoal(attr);
      if (!isFirstLoad) {
        if ((attr.team_score || 0) > prevTeam) pendingScoreFlip = 'team';
        if ((attr.opponent_score || 0) > prevOpp) pendingScoreFlip = 'opponent';
      }
      
      let desired;
      if (live) {
        desired = 15000;
      } else if (gameState === 'PRE' || gameState === 'FUT') {
        desired = 120000;
      } else {
        desired = 300000;
      }
      
      if (desired !== refreshIntervalMs) {
        setRefreshInterval(desired);
        const intervalText = desired === 15000 ? '15s' : desired === 120000 ? '2min' : '5min';
        addLog(`‚è±Ô∏è Adjusted interval: ${intervalText} (Estado: ${gameState})`, 'info');
      }
      
      if (live) {
        addPlayToHistory(attr.last_play, attr.clock);
      } else {
        if (playsHistory.length > 0) {
          playsHistory = [];
        }
      }
      
      const teamHA = (attr.team_homeaway || '').toLowerCase() === 'home' ? 'HOME' : 'AWAY';
      const oppHA = (attr.opponent_homeaway || '').toLowerCase() === 'home' ? 'HOME' : 'AWAY';
      
      let periodLabel;
      if (gameState === 'POST') {
        periodLabel = convertClockTimeZone(attr.clock) || 'Finished';
      } else if (gameState === 'PRE') {
        periodLabel = 'Game starting soon';
      } else {
        periodLabel = `Period ${attr.quarter || '1'}`;
      }

      let shotsHtml = '';
      const sotTeam = (attr.team_shots_on_target != null) ? Number(attr.team_shots_on_target) : null;
      const sotOpp = (attr.opponent_shots_on_target != null) ? Number(attr.opponent_shots_on_target) : null;
      const totTeam = (attr.team_total_shots != null) ? Number(attr.team_total_shots) : null;
      const totOpp = (attr.opponent_total_shots != null) ? Number(attr.opponent_total_shots) : null;
      const useTarget = (sotTeam != null && sotOpp != null);
      const shotsTeam = useTarget ? sotTeam : totTeam;
      const shotsOpp = useTarget ? sotOpp : totOpp;
      const hasShots = (shotsTeam != null && shotsOpp != null);

      if (hasShots) {
          const total = Math.max(1, shotsTeam + shotsOpp);
          const pctTeam = Math.round((shotsTeam / total) * 100);
          const pctOpp = 100 - pctTeam;
          
          shotsHtml = `
            <div class="shots-header">
              <div class="shots-bar-container">
                <div class="top-row">
                  <div class="stat-label">${useTarget ? 'SHOTS ON GOAL' : 'TOTAL SHOTS'}</div>
                  <div class="stat-values">
                    <span class="stat-value" data-tooltip="Team: ${shotsTeam} (${pctTeam}%)" style="color: var(--team-primary);">${shotsTeam}</span>
                    <span class="stat-sep">:</span>
                    <span class="stat-value" data-tooltip="Opponent: ${shotsOpp} (${pctOpp}%)" style="color: var(--opponent-primary);">${shotsOpp}</span>
                  </div>
                </div>
                <div class="shots-bar" id="shotsBar">
                  <div class="team" style="width:${pctTeam}%"></div>
                  <div class="opp" style="width:${pctOpp}%"></div>
                </div>
              </div>
            </div>
          `;
      }

      app.innerHTML = `
        <div class="header">
          <div class="header-left">
            <div class="event-info">
              <h1>${attr.event_url ? `<a href="${attr.event_url}" target="_blank" rel="noopener" style="color:white; text-decoration:none;">${attr.event_name || 'No scheduled game'}</a>` : (attr.event_name || 'No scheduled game')}</h1>
              <p>${attr.venue || 'TBD'} ‚Ä¢ ${attr.location || ''}</p>
            </div>
          </div>
          <div class="header-right">
            <div class="tv-network">${attr.tv_network || ''}</div>
            <div class="game-date">${formatDate(attr.date)} <button class="refresh-btn" id="refreshNow">Refresh now</button></div>
          </div>
        </div>
        
        ${shotsHtml}

        <div class="main-score">
          <div class="team">
            ${attr.team_url ? `<a href="${attr.team_url}" target="_blank" rel="noopener">` : ''}
            <img src="${attr.team_logo || ''}" alt="${attr.team_name || ''}" class="team-logo" onerror="this.style.display='none'">
            ${attr.team_url ? `</a>` : ''}
            <div class="team-name">${attr.team_long_name || 'Team'}</div>
            <div class="team-abbr">${attr.team_abbr || 'TM'}</div>
            <div class="team-record">Record: ${attr.team_record || '0-0-0'}</div>
            <div class="team-badge">${teamHA}</div>
          </div>
          
          <div class="score-center">
            <div class="scores">
              <div id="scoreTeam" class="score ${attr.team_winner ? 'winner' : 'loser'}">${attr.team_score || '0'}</div>
              <div class="score-separator">-</div>
              <div id="scoreOpp" class="score ${attr.opponent_winner ? 'winner' : 'loser'}">${attr.opponent_score || '0'}</div>
            </div>
            
            <div class="status-badge">${convertClockTimeZone(attr.clock) || 'Por definir'}</div>
            ${live ? `<div class="live-inline"><span class="live-dot"></span><span class="live-text">EN VIVO</span></div>` : ''}
            <div class="state-chips">
              ${(/ot/i.test(attr.clock || '')) ? `<span class="state-chip">OT</span>` : ''}
              ${(/so/i.test(attr.clock || '')) ? `<span class="state-chip">SO</span>` : ''}
              ${(/intermission/i.test(attr.clock || '')) ? `<span class="state-chip">Intermission</span>` : ''}
            </div>
            <div class="period-info">${periodLabel}</div>
            
            ${attr.team_winner ? 
              `<div class="winner-badge"><span class="winner-text">${attr.team_abbr} WINS</span></div>` : 
              (attr.opponent_winner ? 
                `<div class="winner-badge"><span class="winner-text">${attr.opponent_abbr} WINS</span></div>` : '')}
          </div>
          
          <div class="team">
            ${attr.opponent_url ? `<a href="${attr.opponent_url}" target="_blank" rel="noopener">` : ''}
            <img src="${attr.opponent_logo || ''}" alt="${attr.opponent_name || ''}" class="team-logo" onerror="this.style.display='none'">
            ${attr.opponent_url ? `</a>` : ''}
            <div class="team-name">${attr.opponent_long_name || 'Opponent'}</div>
            <div class="team-abbr">${attr.opponent_abbr || 'OPP'}</div>
            <div class="team-record">Record: ${attr.opponent_record || '0-0-0'}</div>
            <div class="team-badge">${oppHA}</div>
          </div>
        </div>
        
        <div class="game-details-grid">
          <div class="last-play-section">
            <div class="last-play-title">Recent plays</div>
            <div id="playsTimeline" class="plays-timeline"></div>
          </div>
        </div>
        
        <div class="footer">
          <div class="footer-content">
            <div class="footer-info">
              <span>Comienzo:</span>
              <strong>${attr.kickoff_in || 'Por definir'}</strong>
            </div>
            <div class="last-update">
              √öltima actualizaci√≥n: ${formatTime(attr.last_update)}
            </div>
          </div>
        </div>
      `;
      
      const refreshBtn = document.getElementById('refreshNow');
      if (refreshBtn && !refreshBtn._bound) {
        refreshBtn.addEventListener('click', manualRefresh);
        refreshBtn._bound = true;
      }

      if (!document.getElementById('newPlaysBadge')) {
        const nb = document.createElement('div');
        nb.id = 'newPlaysBadge';
        nb.style.position = 'fixed';
        nb.style.right = '18px';
        nb.style.bottom = '110px';
        nb.style.background = 'rgba(255,255,255,0.08)';
        nb.style.color = '#fff';
        nb.style.padding = '0.45rem 0.7rem';
        nb.style.borderRadius = '999px';
        nb.style.display = 'none';
        nb.style.zIndex = 60;
        nb.style.fontWeight = 700;
        nb.style.boxShadow = '0 8px 24px rgba(0,0,0,0.45)';
        nb.innerText = 'NUEVAS';
        document.body.appendChild(nb);
      }

      try {
        const bar = document.getElementById('shotsBar');
        if (bar) {
          const teamEl = bar.querySelector('.team');
          const oppEl = bar.querySelector('.opp');
          const curTeamW = teamEl ? teamEl.style.width : '';
          if (!bar._lastWidth) bar._lastWidth = curTeamW;
          if (bar._lastWidth !== curTeamW) {
            bar.classList.add('pulse');
            setTimeout(() => bar.classList.remove('pulse'), 900);
            bar._lastWidth = curTeamW;
          }
        }
      } catch (e) {
      }

      try {
        let touchTip = document.getElementById('touchTooltip');
        if (!touchTip) {
          touchTip = document.createElement('div');
          touchTip.id = 'touchTooltip';
          touchTip.className = 'touch-tooltip';
          document.body.appendChild(touchTip);
        }

        const statValues = document.querySelectorAll('.shots-header .stat-value');
        statValues.forEach(el => {
          if (el._touchBound) return;
          el.addEventListener('click', (ev) => {
            const text = el.getAttribute('data-tooltip') || el.innerText || '';
            touchTip.innerText = text;
            const rect = el.getBoundingClientRect();
            touchTip.style.left = (rect.left + rect.width/2) + 'px';
            touchTip.style.top = (rect.top - 48) + 'px';
            touchTip.style.opacity = '1';
            setTimeout(() => { touchTip.style.opacity = '0'; }, 2200);
          });
          el._touchBound = true;
        });

        const timeline = document.getElementById('playsTimeline');
        if (timeline) {
          timeline.querySelectorAll('.play-card').forEach(card => {
            if (card._tapBound) return;
            card.addEventListener('click', () => {
              const expanded = card.classList.toggle('expanded');
              if (expanded) card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
            card._tapBound = true;
          });
        }
      } catch (e) {
      }

      if (pendingScoreFlip) {
        const el = pendingScoreFlip === 'team' ? document.getElementById('scoreTeam') : document.getElementById('scoreOpp');
        if (el) {
          el.classList.add('flip');
          setTimeout(() => el && el.classList && el.classList.remove('flip'), 650);
        }
        pendingScoreFlip = null;
      }

      const appEl2 = document.getElementById('app');
      const leagueOpacity = live ? 0.06 : (gameState === 'POST' ? 0.03 : 0.05);
      appEl2 && appEl2.style.setProperty('--league-opacity', String(leagueOpacity));

      let statusMsg = '';
      if (gameState === 'POST') statusMsg = 'Finished';
      else if (gameState === 'PRE') statusMsg = 'Waiting for game start‚Ä¶';
      updatePlaysTimeline(false, statusMsg);
      
      // IMPORTANT: Restore penalty cards after rendering
      restorePenaltyCards();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INITIALIZATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    addLog('üèí NHL API system started (Home Assistant Proxy)', 'success');
    addLog(`Monitoring: ${INPUT_SELECT}`, 'info');
    addLog('üåê Using: Home Assistant rest_command', 'info');
    
    loadProcessedGoals();
    
    const debugToggleBtn = document.createElement('button');
    debugToggleBtn.id = 'debugToggleFloatingBtn';
    debugToggleBtn.innerHTML = 'üèí';
    debugToggleBtn.title = 'Show/Hide Debug Log';
    debugToggleBtn.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: white;
      font-size: 20px;
      cursor: pointer;
      z-index: 9998;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    `;
    
    debugToggleBtn.addEventListener('mouseenter', () => {
      debugToggleBtn.style.transform = 'scale(1.1)';
      debugToggleBtn.style.background = 'rgba(0, 0, 0, 0.9)';
    });
    
    debugToggleBtn.addEventListener('mouseleave', () => {
      debugToggleBtn.style.transform = 'scale(1)';
      debugToggleBtn.style.background = 'rgba(0, 0, 0, 0.7)';
    });
    
    debugToggleBtn.addEventListener('click', () => {
      const logPanel = document.getElementById('nhlDebugLog');
      if (logPanel) {
        if (logPanel.style.display === 'none') {
          logPanel.style.display = 'block';
          debugToggleBtn.style.opacity = '1';
        } else {
          logPanel.style.display = 'none';
          debugToggleBtn.style.opacity = '0.6';
        }
      }
    });
    
    document.body.appendChild(debugToggleBtn);
    
    updatePanel();
    setRefreshInterval(30000);
  </script>
</body>
</html>
